TestNG/JUnit - Java Unit Testing Framework already developed, 
Open source/Free
Python -> PyTest
Javascript - Mocha, Jasmine
C# - NUnit
PHP - PHPUnit
Unit Testing Framework are there for Developers to write Unit Tests.
Selenium (UI Automation with Java)+TestNG (Validation) -> UI Test Automation
Selenium (UI Automation with Python)+PyTest (Validation) -> UI Test Automation
Selenium (UI Automation with C#)+NUnit (Validation) -> UI Test Automation

JUnit was not that Testing friendly, TestNG is a wrapper on JUnit.
In Eclipse TestNG is not there bydefault
Maven - POM - Add TestNG dependency
Run Test Cases -> Using TestNG Plug-in
In IntelliJ TestNG is there bydefault

In POM.xml, we removed the scope line as earlier it was scope=Test
Meaning we can use TestNG only inside src/test/Java
However If we remove the scope, we can use TestNG inside the package anywhere

Test Cases or Validations should be inside src/test/java
Your core libraries, utlities etc should be inside src/main/java

You can't go to each class and right click and click Run as TestNG
So you have to create a runner, Its bundled in TestNG
testRunner.xml  (Fiule name can be anything but It should be xml file)

src/main/java and src/test/java are for java codes
All the non-java codes should be there under resources
Source Folder -> Give

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE suite SYSTEM "http://testng.org/testng-1.0.dtd">
The above two lines are common in any xml file
Its the schema defination

<test name="Google Test"> test name you can give anything.
These are test blocks not test cases, inside which test classes are there
Class name u have to give as packagename.classname (No Spelling mistake)
and test blocks are executed top to down, not alphabetically
verbose=1 or lies between 1 to 10
verbose 1 means minimum logs in the console after execution
verbose 10 means maximum logs in the console after execution
verbose comes from TestNG

TestSuite name, Test block name and class name all will be populated in the 
console after execution

No need to run individual classes just run the runner file
All classes inside the xml file will be executed

Suppose 100 Test Classes are there inside the same package
Then to run all the 100 classes, you don't have to write all 100
class names inside the xml runner file
but just give the package name*, so all the test classes inside the package 
will be executed

But as per industry standard, 
one single class shoule have a single test block name
Naveen has seen 30 or 40 test blocks in some project

You can't have multiple suite inside testrunner.xml file
But Inside Suite then Test Blcoks then classes inside testrunner.xml file
Two test blocks can't have same test name inside testrunner.xml file
You can even write method name inside class inside testrunner.xml file

Inside runner.xml if you want to run one just select it and right click
and run with testng

If same functionality but diff metadata, then you have to write 
5 soft assertions

But diff functionality means diff hard assertions
only one hard assertion per test cases

 <test name="Google Test">
        <parameter name="url" value="https://www.google.com" />
        <parameter name="browser" value="chrome" />

        <classes>
            <class name="UITests.GoogleTest" />
        </classes>
    </test>

    As shown above parameter value will be passed to the test class (UITests.GoogleTest)
    then to the base class, and in base class we will hold it
    then pass the parameter value to the method.

    We pass configuration data or globl data like URL, Browser, Environment(e.g.QA/dev) from the xml file
    But Imagine a Registration form, having 1st Name , Last Name etc, Do you supply those data
    No we don't , these are test data, we supply from Excel, CSV, Properties File etc

    <suite name="TestNG Regression Suite" verbose="3" thread-count="3" parallel="tests">
    As shown above, don't give any comma, just space separated
    thread-count="3" meaning 3 Threads will be creaed, this facility is provided by TestNG not Java
    If you want to do it through Java, then You have to write code in multi threading
    parallel="tests" meaning run tests, test blocks in parallel
    Parall execution means browsers will be opened simulataneously
    In Sequential execution, one test block will be executed, then after finishing this another test block gets executed
    So Sequential execution takes more time than parallel execution

    Suppose there are 100 Test Blocks, and u write thread-count=100, so 100 browsers will be launched simulataneously
    The RAM and CPU usage will be huge It may crash. It's a bad practise.
    Threads randomly pick test block

    dependsuponmethod and priority concept will fail in parallel execution, but in sequential execution it's ok

    Recommendation-> If 100 Test Blcoks are there Give from 5 to max 10 thread-count
    Don't give thread-count as 50 or 100 or 1000
    So we run using Docker, where test blocks will run in container
    So you can max 10, not even 50 using Docker, max is 5 to 10

    you can create multiple xml runners.

    
    




    


